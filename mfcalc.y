%{
  #include <stdio.h>
  #include <math.h>

  #include "params.h"
  #include "abb.h"
  #include "pila.h"
  #include "commands.h"

  #define GREETING "EtseCalc 1.0.0\nType \"help\" for more information.\n"
  #define PROMPT ">>> "

  int yylex (void);
  void yyerror (char const *);
%}

//Libraries to be included in the header file generated by Bison
%code requires {
  #include "abb.h"
  #include "pila.h"
  #include "errors.h"
}

//YYSTYPE will be generated from these types
%define api.value.type union
%token <double>  NUM
%token <tipoelem> VAR FUN COM
%token <tipoelemPila> ARG
%nterm <double>  exp
%nterm <pila> params

//We define the precedence of the operators
%precedence '='
%left '-' '+'
%left '*' '/'
%precedence NEG /* negation--unary minus */
%right '^'      /* exponentiation */
/* Generate the parser description file. */
%verbose
/* Enable run-time traces (yydebug). */
%define parse.trace

/* Formatting semantic values. */
%printer { fprintf (yyo, "%s", $$.name); } VAR;
%printer { fprintf (yyo, "%s()", $$.name); } FUN;
%printer { fprintf (yyo, "%s()", $$.name); } COM;
%printer { fprintf (yyo, "%g", $$); } <double>;

%% /* The grammar follows. */
input:
  %empty
| input line
  {
    tipoelemPila t = tope(stackInput);
    if(t.value.desc == stdin) printf (PROMPT);
  }
;

line:
  '\n'
| exp '\n'{ if(printFlag) printf ("%.10g\n", $1); }
| exp ';' '\n'
| error '\n' { yyerrok; }
| command '\n'


command:
  COM { $1.value.comm(0, NULL); }
| COM params
  { ParamStruct params = processParamStack(&$2);
    $1.value.comm(params.argc, params.argv);
    removeParamStruct(params);
  }

params:
  ARG { crearPila(&$$); push(&$$, $1); }
| params ARG { push(&$$, $2); }

exp:
  NUM
| VAR                { $$ = $1.value.var;               }
| VAR '=' exp
  { if($1.lvalue) { $$ = $3; $1.value.var = $3; modificar(&sym_table, $1); }
    else { errorExpectedLValue(); YYERROR; }
  }
| FUN '(' exp ')'    { $$ = $1.value.fun ($3);          }
| exp '+' exp        { $$ = $1 + $3;                    }
| exp '-' exp        { $$ = $1 - $3;                    }
| exp '*' exp        { $$ = $1 * $3;                    }
| exp '/' exp        {
                        if($3 == 0) {
                          errorDivisionByZero();
                          YYERROR;
                        } else $$ = $1 / $3;
                     }
| '-' exp  %prec NEG { $$ = -$2;                        }
| exp '^' exp        { $$ = pow ($1, $3);               }
| '(' exp ')'        { $$ = $2;                         }
;
/* End of grammar. */
%%

/* The mfcalc code assumes that malloc and realloc
   always succeed, and that integer calculations
   never overflow.  Production-quality code should
   not make these assumptions.  */
#include <assert.h>
#include <stdlib.h> /* malloc, realloc. */
#include <string.h> /* strlen. */

#include <ctype.h>
#include <stddef.h>
#include <string.h>
#include <dlfcn.h>

#include "errors.h"
#include "initialization.h"
#include "lex.yy.c"

/* Called by yyparse on error. */
void yyerror (char const *s)
{
  errorSyntax(s);
}

int main (int argc, char const* argv[])
{
  /* Enable parse traces on option -p. */
  if (argc == 2 && strcmp(argv[1], "-p") == 0)
    yydebug = 1;
  //We initialize the symbol table and the stack of file descriptors
  crear_arbol(&sym_table);
  crearPila(&stackInput);
  crearPila(&stackDinamic);
  //We add the default constants, functions and commands
  initializeSymbolTable(&sym_table);
  //The first element in our stack of descriptors will be always the standard input
  tipoelemPila t;
  t.value.desc = stdin;
  push(&stackInput, t);
  //We print the greeting message and the prompt
  printf(GREETING PROMPT);
  //We start the parsing
  yyparse ();
  //We close the input bugger
  fclose(yyin);
  yyin = NULL;
  //We destroy the memory associated to flex
  yylex_destroy();
  //We close the descriptors associated to the dynamic libraries
  tipoelemPila tp;
  while(!esVaciaPila(stackDinamic)) {
    tp = tope(stackDinamic);
    dlclose(tp.value.desc);
    pop(&stackDinamic);
  }
  //We free the memory associated to the symbol table and the stack of descriptors
  destruir_arbol(&sym_table);
  destruirPila(&stackInput);
  destruirPila(&stackDinamic);
}
